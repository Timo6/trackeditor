#include <iostream>
#include <sstream>
#include <fstream>

#include <string>
#include <sstream>

#include <list>
#include <vector>

#include <stdexcept>

#include <fnmatch.h>

using namespace std;

vector <string> commandlist;

struct listentry
{
	list <string> entries;
};

list <listentry> listfile;

bool Matches(string pattern, string haystack)
{
	return (fnmatch(pattern.c_str(),haystack.c_str(),0) == 0);
}

string sGetParam(ifstream &ffrom)
{
	string trashstr;
	char trashchar[1024];

	ffrom >> trashstr;

	while (trashstr.c_str()[0] == '#' && !ffrom.eof() && trashstr != "")
	{
		ffrom.getline(trashchar, 1024, '\n');
		ffrom >> trashstr;
	}
	
	if (ffrom.eof() && trashstr.c_str()[0] == '#')
		return "!!!EOF!!!";
	else
		return trashstr;
}

void ReadListFile(string filename)
{
	listfile.clear();
	
	int numformat = 10;
	
	/*ifstream ff("listformat.txt");
	if (ff)
	{
		ff >> numformat;
		cout << "Using " << numformat << " parameters per entry." << endl;
		ff.close();
	}
	else
	{
		cout << "Using default " << numformat << " parameters per entry." << endl;
	}*/
	
	ifstream lf;
	lf.open(filename.c_str());
	if (lf)
	{
		//lf >> numformat;
		numformat = atoi(sGetParam(lf).c_str());
		
		cout << "Using " << numformat << " parameters per entry." << endl;
		
		if (numformat < 1)
		{
			cout << "Parameters per entry number doesn't make sense!" << endl;
		}
		
		unsigned int count = 0;
		
		string param;
		while (!lf.eof() && param != "!!!EOF!!!" && count < 1000000)
		{
			struct listentry newentry;
			
			for (int i = 0; i < numformat; i++)
			{
				param = sGetParam(lf);
				newentry.entries.push_back(param);
			}
			
			if (param != "!!!EOF!!!" && !lf.eof())
				listfile.push_back(newentry);
			
			count++;
			
			//if (count % 100 == 0)
				//cout << "Loading... (" << count << ")" << endl;
		}
		
		cout << "Read " << listfile.size() << " entries." << endl;
	}
	else
	{
		cout << "Can't find " << filename << endl;
	}
}

void WriteListFile(string filename)
{	
	if (listfile.size() < 1)
	{
		cout << "No entries, not saving an empty list file." << endl;
		return;
	}
	
	/*int numformat = 10;
	ifstream ff("listformat.txt");
	if (ff)
	{
		ff >> numformat;
		cout << "Using " << numformat << " parameters per entry." << endl;
		ff.close();
	}
	else
	{
		cout << "Using default " << numformat << " parameters per entry." << endl;
	}*/
	
	ofstream lf;
	lf.open(filename.c_str());
	if (lf)
	{
		lf << "# File generated by listedit, a VDrift track editor tool" << endl << endl;
		
		lf << listfile.begin()->entries.size() << endl << endl;
		
		int count = 0;
		
		for (list <listentry>::iterator i = listfile.begin(); i != listfile.end(); i++)
		{
			lf << "#entry " << count << endl;
			for (list <string>::iterator n = i->entries.begin(); n != i->entries.end(); n++)
			{
				lf << *n << endl;
			}
			
			lf << endl;
			count++;
		}
		
		cout << "Wrote " << listfile.size() << " entries." << endl;
	}
	else
	{
		cout << "Can't open " << filename << " for writing" << endl;
	}
}

void trim(string & istr)
{
	//trim the string
	istr.erase(0, istr.find_first_not_of(" \t\n"));

	try
	{
		istr.erase(istr.find_last_not_of(" \t\n") + 1);
	}
	catch(std::out_of_range)
	{
		
	}
}

void go(string com, string arg)
{
	if (com == "help")
	{
		vector <string>::iterator i;
		for (i = commandlist.begin(); i != commandlist.end(); i++)
		{
			cout << *i << endl;
		}
	}
	/*else if (com == "mem")
	{
		cout << "mem used: " << db.MemoryFootPrint(false, true) << " bytes data, " << 
			db.MemoryFootPrint(true, true) << " bytes total" << endl;
	}*/
	else if (com == "load")
	{
		if (arg.empty())
		{
			arg = "list.txt";
		}
		
		ReadListFile(arg);
	}/*
	else if (com == "merge")
	{
		if (arg.empty())
		{
			arg = "in.txt";
		}
		
		db.ReadPartialASCII(arg.c_str());	
	}*/
	else if (com == "save")
	{
		if (arg.empty())
		{
			arg = "listout.txt";
		}
		
		WriteListFile(arg);
	}/*
	else if (com == "test")
	{
		cout << "\"" << com << "\",\"" << arg << "\"" << endl;
	}
	else if (com == "cat")
	{
		NODE * cur = curnode;
		if (!arg.empty())
		{
			cur = curnode->GetChild(arg);
		}
		
		//cout << cur->DebugPrint() << endl;
		if (cur != NULL)
			cur->DebugPrint();
	}*/
	else if (com == "ls" || com == "no")
	{
		stringstream argstream;
		argstream.str(arg);
		int matchentry = 0;
		string pattern = "*";
		if (!arg.empty())
		{
			argstream >> matchentry;
			argstream >> pattern;
		}
		
		if (pattern == "")
			pattern = "*";
		
		for (list <listentry>::iterator i = listfile.begin(); i != listfile.end(); i++)
		{
			int count = 0;
			bool match = false;
			for (list <string>::iterator n = i->entries.begin(); n != i->entries.end(); n++)
			{
				if (count == matchentry)
				{
					if (Matches(pattern, *n))
						match = true;
				}
				count++;
			}
			
			if (match)
			{
				count = 0;
				for (list <string>::iterator n = i->entries.begin(); n != i->entries.end(); n++)
				{
					if (count == 0)
					{
						cout << *n << endl;
					}
					count++;
				}
			}
		}
	}
	else if (com == "set")
	{
		stringstream argstream;
		argstream.str(arg);
		int matchentry = 0;
		string pattern = "*";
		int setnum = 0;
		string setvalue;
		if (!arg.empty())
		{
			argstream >> matchentry;
			argstream >> pattern;
			argstream >> setnum;
			argstream >> setvalue;
		}
		
		if (pattern == "")
			pattern = "*";
		
		if (setvalue.empty())
		{
			cout << "Empty set value." << endl;
		}
		else
		{
			int num_set = 0;
			for (list <listentry>::iterator i = listfile.begin(); i != listfile.end(); i++)
			{
				int count = 0;
				bool match = false;
				for (list <string>::iterator n = i->entries.begin(); n != i->entries.end(); n++)
				{
					if (count == matchentry)
					{
						if (Matches(pattern, *n))
							match = true;
					}
					count++;
				}
				
				if (match)
				{
					count = 0;
					for (list <string>::iterator n = i->entries.begin(); n != i->entries.end(); n++)
					{
						if (count == setnum)
						{
							*n = setvalue;
							num_set++;
						}
						count++;
					}
				}
			}
			
			cout << "Set " << num_set << " entries." << endl;
		}
	}
	else if (com == "addparam")
	{
		for (list <listentry>::iterator i = listfile.begin(); i != listfile.end(); i++)
		{
			i->entries.push_back(arg);
		}
	}
	/*else if (com == "info")
	{
		curnode->DebugPrint();
	}
	else if (com == "cleardata")
	{
		NODE * cur = curnode;
		if (!arg.empty())
		{
			cur = curnode->GetChild(arg);
		}
		
		if (cur == NULL)
			cout << "Child not found: " << arg << endl;
		else
		{		
			cur->data_str.clear();
			cur->data_dbl.clear();
			cur->data_ptr.clear();
		}
	}
	else if (com == "cleardata")
	{
		NODE * cur = curnode;
		if (!arg.empty())
		{
			cur = curnode->GetChild(arg);
		}
		
		if (cur == NULL)
			cout << "Child not found: " << arg << endl;
		else
		{		
			cur->ClearListData();
		}
	}
	else if (com == "set" || com == "set-s" || com == "set-d")
	{
		NODE * cur = curnode;
		if (!arg.empty())
		{
			cur = curnode->GetChild(arg);
		}
		
		cout << "input data: ";
		string newdata;
		char buffer[1024];
		cin.getline(buffer, 1024);
		newdata = buffer;
		trim(newdata);
		
		if (cur == NULL)
		{
			//curnode->AddChild(arg, newdata);
			cout << "Child not found: " << arg << endl;
		}
		else
		{
			//cur->data.Set(newdata);
			if (com == "set" || com == "set-s")
			{
				cur->SetSingleString(newdata);
			}
			else if (com == "set-d")
			{
				double tdbl = atof(newdata.c_str());
				cur->SetSingleDouble(tdbl);
			}
		}
	}
	else if (com == "nset" || com == "nset-s" || com == "nset-d")
	{
		char buffer[1024];
		
		NODE * cur = curnode;
		if (!arg.empty())
		{
			cur = curnode->GetChild(arg);
		}
		
		if (cur == NULL)
		{
			//curnode->AddChild(arg, newdata);
			cout << "Child not found: " << arg << endl;
		}
		else
		{
			unsigned int num;
			cout << "input n: ";
			cin.getline(buffer, 1024);
			num = atoi(buffer);
			
			if (com == "nset" || com == "nset-s")
				cur->data_str.clear();
			else if (com == "nset-d")
				cur->data_dbl.clear();
			
			for (unsigned int i = 0; i < num; i++)
			{
				cout << "input data " << i << ": ";
				string newdata;
				cin.getline(buffer, 1024);
				newdata = buffer;
				trim(newdata);
				
				if (com == "nset" || com == "nset-s")
				{
					cur->data_str.push_back(newdata);
				}
				else if (com == "nset-d")
				{
					double tdbl = atof(newdata.c_str());
					cur->data_dbl.push_back(tdbl);
				}
			}
		}
	}
	else if (com == "cd")
	{
		if (arg == "..")
		{
			if (curnode->data_parent != NULL)
				curnode = curnode->data_parent;
		}
		else
		{
			if (!arg.empty())
			{
				NODE * newcur = curnode->GetChild(arg);
				if (newcur != NULL)
					curnode = newcur;
			}
		}
	}
	else if (com == "cdl")
	{
		if (arg == "..")
		{
			if (curnode->data_parent != NULL)
				curnode = curnode->data_parent;
		}
		else
		{
			if (!arg.empty())
			{
				unsigned int wantcount = atoi(arg.c_str());
				NODE * newcur = NULL;
				unsigned int count = 0;
				for (list < NODE * >::iterator i = curnode->data_list.begin(); i != curnode->data_list.end(); i++,count++)
				{
					if (count == wantcount)
						newcur = *i;
				}
				
				if (newcur != NULL)
					curnode = newcur;
			}
		}
	}*/
	else if (com == "quit")
	{
		
	}
	else if (com == "abort")
	{

	}
	else
	{
		cout << "unknown command: " << com << endl;
	}
}

int main(int argc, char *argv[])
{
	
	if (argc > 1)
		ReadListFile(argv[1]);
	//else
		//db.ReadPartialASCII("autosave.txt");
	
	string command = "";
	
	/*commandlist.push_back("mem - Memory usage info");*/
	commandlist.push_back("addparam - Add a new parameter to the file format");
	commandlist.push_back("ls - List entries");
	/*commandlist.push_back("cd - Change directory");
	commandlist.push_back("cdl - Change directory into list child");
	commandlist.push_back("cat - Output contents of node");
	commandlist.push_back("mkdir - Make a new node");
	commandlist.push_back("rm - Recursively delete nodes");*/
	commandlist.push_back("set - Set entries");
	/*commandlist.push_back("set-s - Set a node to a string value");
	commandlist.push_back("set-d - Set a node to a numeric value");
	commandlist.push_back("nset - Identical to nset-s");
	commandlist.push_back("nset-s - Set a node to n string values");
	commandlist.push_back("nset-d - Set a node to n numeric values");
	commandlist.push_back("cleardata - Clear a node's data");
	commandlist.push_back("clearlist - Clear a node's list");
	commandlist.push_back("cp - Copy a node");
	commandlist.push_back("info - Some info about the current node");*/
	commandlist.push_back("load - Read list file");
	//commandlist.push_back("merge - Merge in ASCII file data");
	commandlist.push_back("save - Write list file");
	commandlist.push_back("quit");
	
	while (command != "quit" && command != "abort")
	{
		//string prompt = "> " + curnode->GetFullHandle();
		string prompt = ">";
		string input;
		prompt.append(" $ ");
		cout << endl << prompt;
		char buffer[1024];
		cin.getline(buffer, 1024);
		input = buffer;
		
		//trim the string
		trim(input);
		
		//parse the string
		unsigned int tokloc = 0;
		
		tokloc = input.find(' ', 0);
		if (tokloc != 0)
		{
			command = input.substr(0, tokloc);
		}
		
		string arg = "";
		if (tokloc < input.length())
			arg = input.substr(tokloc+1);
		
		trim(command);
		trim(arg);
		
		go(command, arg);
	}
	
	//db.WriteASCII("out.txt");
	if (command != "abort")
	{
		if (argc > 1)
			WriteListFile(argv[1]);
		//WriteListFile("list-autosave.txt");
	}
	
	listfile.clear();
	
	return 0;
}
